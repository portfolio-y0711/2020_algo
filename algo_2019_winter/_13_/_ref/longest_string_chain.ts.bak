//let cached = new Map(_map);
//const keys = Array.from(cached.keys()).sort();
//if (cached.size == 1) {
//return keys[0];
//}

//if (
//keys[1] == keys[0] + 1 &&
//cached
//.get(keys[0])
//.filter(x0 =>
//cached.get(keys[1]).some(x1 => x0.split("").every(c => x1.includes(c)))
//).length > 0
//) {
//cached.delete(keys[0]);
//}
//return getMaxChainLength(cached);

const groupByLength = (words: string[]): Map<number, Array<string>> =>
  words.reduce((acc: any | Map<number, Array<string>>, word) => {
    let key = word.length,
      arr: Array<string>;
    if (acc.has(key)) arr = acc.get(key);
    else arr = new Array<string>();
    arr.push(word);
    acc.set(key, arr);
    return acc;
  }, new Map<number, Array<string>>());

const sampleProvider = (num: number) => {
  const example = [
    ["a", "b", "ba", "bca", "bda", "bdca"],
    ["c", "b", "ca", "bca", "bda", "bdca"]
  ];
  return example[num];
};

// console.log(longestStrChain(["a", "b", "ba", "bca", "bda", "bdca"]));
//console.log(
//longestStrChain([
//"ksqvsyq",
//"ks",
//"kss",
//"czvh",
//"zczpzvdhx",
//"zczpzvh",
//"zczpzvhx",
//"zcpzvh",
//"zczvh",
//"gr",
//"grukmj",
//"ksqvsq",
//"gruj",
//"kssq",
//"ksqsq",
//"grukkmj",
//"grukj",
//"zczpzfvdhx",
//"gru"
//])
//);

export { sampleProvider, groupByLength };
